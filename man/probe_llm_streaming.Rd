% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/register_probe_request.R
\name{probe_llm_streaming}
\alias{probe_llm_streaming}
\title{Probe an LLM endpoint (non-stream + streaming, SSE-aware)}
\usage{
probe_llm_streaming(url, headers, body, stream_param, timeout = 120)
}
\arguments{
\item{url}{Character(1). Endpoint URL.}

\item{headers}{Named list of HTTP headers (e.g., \code{Content-Type},
\code{Authorization}). Keys must be unique.}

\item{body}{Either a list (will be JSON-encoded with \code{auto_unbox = TRUE})
or a character(1) JSON string. Non-stream probe forces \code{stream = FALSE};
streaming probe forces \code{stream = TRUE}.}

\item{stream_param}{Character scalar (optional).
Name of the request-body field used by the provider to enable stream.}

\item{timeout}{Integer(1). Per-request timeout in seconds. Applies to both
non-stream and stream attempts.}
}
\value{
A list with three elements:
\describe{
  \item{non_stream}{List with fields:
    \itemize{
      \item \code{raw_text}: character, raw HTTP body.
      \item \code{status_code}: integer HTTP status.
      \item \code{parsed}: parsed JSON object (or \code{NULL} if parsing fails).
      \item \code{usage}: best-effort extraction of usage block (or \code{NULL}).
    }
  }
  \item{stream_attempt}{List with fields:
    \itemize{
      \item \code{requested_streaming}: logical, always \code{TRUE}.
      \item \code{honored_streaming}: logical, whether SSE markers were seen.
      \item \code{accept_required}: logical, whether SSE appeared only after adding
        \code{Accept: text/event-stream}.
      \item \code{reason}: short diagnostic message.
      \item \code{raw_lines}: character vector of SSE lines as received.
      \item \code{raw_df}: data frame of parsed deltas (id, model, index, role,
        \code{content}, \code{reasoning_content}, \code{finish_reason}); may be empty.
      \item \code{raw_json}: list of parsed SSE \code{data: \{...\}} payloads.
    }
  }
  \item{input}{Echo of inputs: \code{list(url, headers, body)}.}
}
}
\description{
Sends two probes to a model endpoint using the given \code{url}, \code{headers},
and \code{body}:
\enumerate{
  \item \strong{Non-streaming POST}: captures raw response text, HTTP status,
    a parsed JSON object (when parseable), and any usage block.
  \item \strong{Streaming attempt (SSE)}: first tries without an \code{Accept}
    header; if no SSE markers are detected, retries with
    \code{Accept: text/event-stream}. All SSE lines are returned along with a
    lightweight frame of deltas and the raw parsed JSON events.
}
}
\details{
Internally, the function toggles common streaming keys in \code{body} (e.g.,
\code{stream}, \code{streaming}) and parses SSE frames that begin with
\code{data:}. It does not assume any vendor schema beyond standard SSE.


\strong{SSE detection.} Streaming is considered honored if any line matches
\code{^data:\\s*\\\{} (i.e., a JSON object after \code{data:}). The function
first attempts without an \code{Accept} header and retries with
\code{Accept: text/event-stream} only if no SSE markers are observed.

\strong{Safety.} This function does not log or redact secrets. Callers are
responsible for redacting/omitting API keys in logs.

\strong{Errors.} Network issues and HTTP errors are returned via the
\code{non_stream$status_code} when possible; SSE parsing is best-effort and
yields empty structures if no valid frames are detected.
}
\section{Typical fields in \code{raw_df} (when present)}{

\itemize{
  \item \code{content}: token text deltas (chat-style).
  \item \code{reasoning_content}: reasoning/think deltas (if provider emits them).
  \item \code{finish_reason}: stream finish status per choice (if emitted).
}
}

\seealso{
\code{\link{llm_register}}, \code{\link{get_registry_entry}}
}
