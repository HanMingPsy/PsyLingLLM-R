#' Run Factorial Trial Experiment (registry-driven, assistant-native)
#'
#' Builds a factorial trial list (carrier sentences × factor levels × optional CW),
#' constructs a stimulus for each row (via `fill_method` or sensible defaults),
#' and calls \code{llm_caller()} for each trial using the package registry
#' (no manual headers/body here).
#'
#' The trial list is generated by \code{generate_llm_factorial_experiment_list()},
#' which yields columns such as \code{Run}, \code{Item}, \code{Material} (carrier),
#' \code{Word} (CW), factor columns, and optionally \code{TrialPrompt}.
#' This function then produces a per-row user message (stimulus) and executes the trials.
#'
#' ## Stimulus construction
#' - If \code{fill_method} is provided, it is called as:
#'   \preformatted{
#'   fill_method(
#'     condition = list(<Factor> = <Level>, ...),
#'     material  = <carrier sentence>,
#'     word      = <CW string or NA>
#'   )
#'   }
#'
#' - If \code{fill_method} is \code{NULL}, defaults to:
#'   1) Replace the first occurrence of one of the placeholders
#'      \code{"\\{CW\\}"}, \code{"[CW]"}, \code{"__CW__"}, or \code{"____"}
#'      in \code{Material} with \code{Word} (if non-NA);
#'   2) Otherwise, \code{paste(Material, Word)} if a CW word exists;
#'   3) Otherwise, just \code{Material}.
#'
#' ## Error & timeout handling
#' - Timeout inside \code{llm_caller()} returns \code{status = 599} → \code{TrialStatus = "TIMEOUT"} (continue).
#' - HTTP error (\code{status >= 400}) → \code{TrialStatus = "ERROR"} (continue).
#'
#' @param model_key Character(1). Registry key (e.g., \code{"deepseek-chat"} or \code{"deepseek-chat@proxy"}).
#' @param generation_interface Character(1). Interface name; default \code{"chat"}.
#' @param api_key Character(1). Provider API key.
#' @param api_url Optional character(1). Overrides registry default URL; required for non-official providers.
#' @param data A \code{data.frame} or a file path accepted by
#'   \code{generate_llm_factorial_experiment_list()}. Must contain at least
#'   \code{Material} (carrier). If using CW, also provide \code{CW} or \code{Word}.
#' @param factors A named list of factors, e.g.,
#'   \code{list(Congruity = c("Congruent", "Incongruent"))}.
#' @param CW Optional \code{data.frame} with \code{Item} plus columns named by
#'   factor-level combinations in wide format.
#' @param fill_method Optional function to build the per-row stimulus (see "Stimulus construction").
#' @param trial_prompt Optional character(1). Global trial prefix; row-level \code{TrialPrompt}
#'   (if present) takes precedence.
#' @param system_content Optional character(1) or \code{NULL}. If \code{NULL},
#'   registry \code{default_system} is used when available.
#' @param assistant_content Optional static few-shot seed: a character vector or a list of
#'   message objects (\code{list(role = ..., content = ...)}). These appear before
#'   rolling history and are preserved as-is.
#' @param optionals Optional named list. If not supplied, defaults are used (tri-state);
#'   if \code{NULL}, no defaults are injected; if a list, only user keys are sent.
#' @param role_mapping Optional mapping of roles (\code{system}/\code{user}/\code{assistant}).
#'   If absent, registry mapping applies.
#' @param stream Logical(1) or \code{NULL}. If \code{NULL}, uses the registry default;
#'   otherwise forces streaming/non-streaming.
#' @param timeout Integer(1). Per-request timeout in seconds (passed to \code{llm_caller()}).
#' @param repeats Integer(1). Number of repetitions per factorial row.
#' @param random Logical(1). Randomize trial order.
#' @param delay Numeric(1). Delay (seconds) between trials.
#' @param output_path Character or \code{NULL}. Path to save results/logs
#'   (same behavior as \code{trial_experiment()}).
#' @param overwrite Logical(1). Overwrite existing outputs.
#' @param return_raw Logical(1). Include raw request/response for debugging.
#'
#' @return A \code{data.frame} (or tibble) with PsyLingLLM schema columns per trial:
#'   \code{Response}, \code{Think}, \code{ModelName}, \code{TotalResponseTime},
#'   \code{FirstTokenLatency}, \code{PromptTokens}, \code{CompletionTokens},
#'   \code{TrialStatus}, \code{Streaming}, \code{Timestamp}, \code{RequestID},
#'   plus \code{Stimulus} and \code{ConditionLabel}.
#'
#' @export
factorial_trial_experiment <- function(
    model_key,
    generation_interface = "chat",
    api_key,
    api_url = NULL,
    data,
    factors,
    CW = NULL,
    fill_method = NULL,
    trial_prompt = NULL,
    system_content = NULL,
    assistant_content = NULL,
    optionals = NULL,
    role_mapping = NULL,
    stream = NULL,
    timeout = getOption("psylingllm.llm_timeout_sec", 120L),
    repeats = 1,
    random = FALSE,
    delay = 0,
    output_path = NULL,
    overwrite = TRUE,
    return_raw = FALSE
) {
  `%||%` <- function(a, b) if (is.null(a) || length(a) == 0) b else a
  safe_chr <- function(x) if (is.null(x) || length(x) == 0 || all(is.na(x))) NA_character_ else as.character(x)[1]
  safe_num <- function(x) if (is.null(x) || length(x) == 0 || all(is.na(x))) NA_real_ else as.numeric(x)[1]
  safe_int <- function(x) if (is.null(x) || length(x) == 0 || all(is.na(x))) NA_integer_ else as.integer(x)[1]

  # ---- Build factorial trial list ------------------------------------------
  if (!exists("generate_llm_factorial_experiment_list")) {
    stop("generate_llm_factorial_experiment_list() not found.")
  }
  trials <- generate_llm_factorial_experiment_list(
    data = data,
    factors = factors,
    CW = CW,
    trial_prompt = trial_prompt %||% "",
    repeats = repeats,
    random = random,
    force_base_cols = TRUE
  )
  if (!("Material" %in% names(trials))) {
    stop("Generated trial list has no 'Material' column.")
  }
  # factor names present in df (for building condition label)
  factor_names <- intersect(names(trials), names(factors))

  # ---- Validate config ------------------------------------------------------
  validate_experiment_config(
    api_key = api_key,
    api_url = api_url,
    model = model_key,
    data = trials,
    required_cols = c("Material"),
    generation_interface = generation_interface
  )

  # ---- Output & log paths ---------------------------------------------------
  paths <- resolve_output_and_log(output_path, model_key)
  result_file <- paths$result_file
  logfile <- paths$log_file

  # ---- Stimulus builder (fill_method or default) ----------------------------
  default_fill <- function(condition, material, word) {
    m <- as.character(material %||% "")
    w <- as.character(word %||% "")
    if (nzchar(w)) {
      # replace a placeholder if present
      for (ph in c("\\{CW\\}", "\\[CW\\]", "__CW__", "____")) {
        if (grepl(ph, m)) return(sub(ph, w, m))
      }
      return(paste(m, w))
    }
    m
  }
  make_stimulus <- function(row) {
    cond_list <- if (length(factor_names)) as.list(row[factor_names]) else list()
    names(cond_list) <- factor_names
    cw <- if ("Word" %in% names(row)) row$Word else NA_character_
    fm = fill_method %||% default_fill
    fm(condition = cond_list, material = row$Material, word = cw)
  }

  # ---- Initialize schema columns -------------------------------------------
  trials$Stimulus <- vapply(seq_len(nrow(trials)), function(i) make_stimulus(trials[i, , drop = FALSE]), character(1))
  trials$ConditionLabel <- if (length(factor_names)) {
    apply(trials[, factor_names, drop = FALSE], 1, function(x) paste(paste(factor_names, x, sep = "="), collapse = " | "))
  } else NA_character_

  n_trials <- nrow(trials)
  trials$Response <- NA_character_
  trials$Think <- NA_character_
  trials$ModelName <- model_key
  trials$TotalResponseTime <- NA_real_
  trials$FirstTokenLatency <- NA_real_
  trials$PromptTokens <- NA_integer_
  trials$CompletionTokens <- NA_integer_
  trials$TrialStatus <- NA_character_
  trials$Streaming <- NA
  trials$Timestamp <- NA_character_
  trials$RequestID <- NA_character_

  # ---- Log start ------------------------------------------------------------
  write_experiment_log(
    logfile,
    stage = "start",
    model = model_key,
    streaming = isTRUE(stream),
    total_runs = n_trials,
    output_path = result_file
  )

  # ---- Progress bar ---------------------------------------------------------
  start_time <- Sys.time()
  bar_width <- 40
  update_progress_bar(0, n_trials, start_time, bar_width, model_key)

  # ---- Trials loop ----------------------------------------------------------
  for (i in seq_len(n_trials)) {
    t0 <- Sys.time()

    # Row-level prompt: prefer row TrialPrompt, else global trial_prompt
    row_prompt <- if ("TrialPrompt" %in% names(trials)) safe_chr(trials$TrialPrompt[i]) else NA_character_
    eff_prompt <- if (!is.na(row_prompt) && nzchar(row_prompt)) row_prompt else trial_prompt

    parsed_resp <- tryCatch(
      llm_caller(
        model_key = model_key,
        generation_interface = generation_interface,
        api_key = api_key,
        api_url = api_url,
        trial_prompt = eff_prompt,
        material = safe_chr(trials$Stimulus[i]),
        system_content = system_content,
        assistant_content = assistant_content,
        optionals = optionals,
        role_mapping = role_mapping,  # user-provided only
        stream = stream,              # tri-state honored in llm_caller
        timeout = timeout,
        return_raw = return_raw
      ),
      error = function(e) handle_llm_error(run_id = i, err = e, category = "network")
    )

    t1 <- Sys.time()
    status_num <- suppressWarnings(as.integer(parsed_resp$status %||% NA_integer_))
    err_msg <- safe_chr(parsed_resp$error)

    # ---- TIMEOUT (599) ------------------------------------------------------
    if (!is.na(status_num) && status_num == 599L) {
      trials$Response[i] <- NA_character_
      trials$Think[i] <- NA_character_
      trials$TotalResponseTime[i] <- as.numeric(difftime(t1, t0, units = "secs"))
      trials$FirstTokenLatency[i] <- NA_real_
      trials$PromptTokens[i] <- NA_integer_
      trials$CompletionTokens[i] <- NA_integer_
      trials$TrialStatus[i] <- "TIMEOUT"
      trials$Streaming[i] <- parsed_resp$streaming %||% isTRUE(stream)
      trials$Timestamp[i] <- format(Sys.time(), "%Y-%m-%d %H:%M:%S")
      trials$RequestID[i] <- NA_character_

      write_experiment_log(
        logfile, stage = "warning", run_id = i,
        msg = sprintf("Trial %d timeout (status=599): %s", i, err_msg)
      )
      if (delay > 0) Sys.sleep(delay)
      update_progress_bar(i, n_trials, start_time, bar_width, model_key)
      next
    }

    # ---- HTTP ERROR (>=400) -------------------------------------------------
    if (!is.na(status_num) && status_num >= 400L) {
      trials$Response[i] <- NA_character_
      trials$Think[i] <- NA_character_
      trials$TotalResponseTime[i] <- as.numeric(difftime(t1, t0, units = "secs"))
      trials$FirstTokenLatency[i] <- NA_real_
      trials$PromptTokens[i] <- NA_integer_
      trials$CompletionTokens[i] <- NA_integer_
      trials$TrialStatus[i] <- "ERROR"
      trials$Streaming[i] <- parsed_resp$streaming %||% isTRUE(stream)
      trials$Timestamp[i] <- format(Sys.time(), "%Y-%m-%d %H:%M:%S")
      trials$RequestID[i] <- NA_character_

      write_experiment_log(
        logfile, stage = "error", run_id = i,
        msg = sprintf("Trial %d HTTP %s: %s", i, status_num, err_msg)
      )
      if (delay > 0) Sys.sleep(delay)
      update_progress_bar(i, n_trials, start_time, bar_width, model_key)
      next
    }

    # ---- SUCCESS ------------------------------------------------------------
    trials$Response[i] <- safe_chr(parsed_resp$response %||% parsed_resp$answer)
    trials$Think[i] <- safe_chr(parsed_resp$think %||% parsed_resp$thinking)
    trials$TotalResponseTime[i] <- as.numeric(difftime(t1, t0, units = "secs"))

    ft <- parsed_resp$FirstTokenLatency %||%
      parsed_resp$first_token_latency %||%
      parsed_resp$latency$first_token
    trials$FirstTokenLatency[i] <- safe_num(ft)

    ptoks <- parsed_resp$PromptTokens %||% parsed_resp$usage$prompt
    ctoks <- parsed_resp$CompletionTokens %||% parsed_resp$usage$completion
    trials$PromptTokens[i] <- safe_int(ptoks)
    trials$CompletionTokens[i] <- safe_int(ctoks)

    trials$TrialStatus[i] <- parsed_resp$TrialStatus %||% "SUCCESS"
    trials$Streaming[i] <- parsed_resp$streaming %||% isTRUE(stream)
    trials$Timestamp[i] <- format(Sys.time(), "%Y-%m-%d %H:%M:%S")
    trials$RequestID[i] <- safe_chr(parsed_resp$usage$id)

    if (delay > 0) Sys.sleep(delay)
    update_progress_bar(i, n_trials, start_time, bar_width, model_key)
  }

  # ---- Finalize & save ------------------------------------------------------
  update_progress_bar(n_trials, n_trials, start_time, bar_width, model_key)
  cat("\n")

  save_experiment_results(
    trials,
    output_path = result_file,
    model = model_key,
    overwrite = overwrite,
    auto_naming = FALSE
  )

  elapsed <- as.numeric(difftime(Sys.time(), start_time, units = "secs"))
  write_experiment_log(
    logfile,
    stage = "end",
    total_runs = n_trials,
    success = sum(trials$TrialStatus == "SUCCESS", na.rm = TRUE),
    failed = sum(trials$TrialStatus %in% c("ERROR", "TIMEOUT"), na.rm = TRUE),
    elapsed = elapsed,
    output_path = result_file
  )

  invisible(trials)
}
